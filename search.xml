<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>my-crypto-3</title>
      <link href="/2024/11/02/my-crypto-3/"/>
      <url>/2024/11/02/my-crypto-3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-欧拉计划-link">1.欧拉计划(<a href="https://projecteuler.net/problem=182">link</a>)</h2><p>本题需要计算所有满足条件e的总和，需要在e加密的情况下为加密的信息数目是最小的。所以首先我们需要编写计算最大公约数的函数<code>gcd()</code>这里运用欧几里得方法得到，减少时间复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">if</span> b ==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> gcd(b,a%b)</span><br></pre></td></tr></table></figure><p>由题目知道未加密信息满足算式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>m</mi><mi>e</mi></msup><mo>≡</mo><mi>m</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">m^{e}\equiv m mod n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mm</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal">n</span></span></span></span>则未加密的信息数目就是该算式解的个数。又<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mi>p</mi><mo>∗</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">n = p*q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6597em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>可以得到解个数公式该方程解个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>g</mi><mi>c</mi><mi>d</mi><mtext>⁡</mtext><mo stretchy="false">(</mo><mi>e</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>g</mi><mi>c</mi><mi>d</mi><mtext>⁡</mtext><mo stretchy="false">(</mo><mi>e</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>q</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(gcd⁡(e-1,p-1)+1)*(gcd⁡(e-1,q-1)+1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mord">⁡</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">c</span><span class="mord mathnormal">d</span><span class="mord">⁡</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，由此我们能够遍历所有的e的可能，并且记录下对应未加密信息数目。最后统计出最小的未加密信息数值，累加得到所有满足条件的e。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    p=<span class="number">1009</span></span><br><span class="line">    q=<span class="number">3643</span></span><br><span class="line">    phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">    e_state = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,phi):</span><br><span class="line">        <span class="keyword">if</span> gcd(e,phi)==<span class="number">1</span>:</span><br><span class="line">            e_state[e]=(gcd(e-<span class="number">1</span>,p-<span class="number">1</span>)+<span class="number">1</span>)*(gcd(e-<span class="number">1</span>,q-<span class="number">1</span>)+<span class="number">1</span>)</span><br><span class="line">    min_result = <span class="built_in">min</span>(e_state.values())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;未加密信息的数目为最小值:&quot;</span>,min_result)</span><br><span class="line">    e_sum = <span class="built_in">sum</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> e_state <span class="keyword">if</span> e_state[i] == min_result])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;e的和&quot;</span>,e_sum)</span><br></pre></td></tr></table></figure><p>最后运行程序得到<strong>答案</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">未加密信息的数目为最小值: 9</span><br><span class="line">e的和 399788195976</span><br></pre></td></tr></table></figure><h2 id="2-实施RSA（link）">2.实施RSA（<a href="https://www.cryptopals.com/sets/5/challenges/39">link</a>）</h2><p>本题要我们实施RSA密码，首先需要编写一个生成大素数的函数，但是在题目中说生成大素数不是重点可以运用已经存在库函数实现。所以我使用<code>getPrime(bits)</code>来得到随机大素数，需要引用如下库函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime</span><br></pre></td></tr></table></figure><p>首先我们需要编写一个运算逆的函数<code>invmod(a, b)</code>，题目中提示运用欧几里得方法来运算。首先我们得到a和b的最大公约数，在ab互素的情况下得到ax+by=1中x和y的值。进而知道x%b就是a对模b的逆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">invmod</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">egcd</span>(<span class="params">a, b</span>):</span><br><span class="line">        <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> b, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        g, x1, y1 = egcd(b % a, a)</span><br><span class="line">        x = y1 - (b // a) * x1</span><br><span class="line">        y = x1</span><br><span class="line">        <span class="keyword">return</span> g, x, y</span><br><span class="line"></span><br><span class="line">    g, x, y = egcd(a, b)</span><br><span class="line">    <span class="keyword">if</span> g != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;模逆不存在&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x % b</span><br></pre></td></tr></table></figure><p>然后我们需要编写生成公钥和私钥的函数<code>def generate_rsa_keys(bits=1024)</code>这里假设生成的大素数长度为1024bits。需要注意是的生成的pq必须满足et和e要互素，否则需要提示‘e和et不互素，需要重新生成p和q’重新运行本程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_rsa_keys</span>(<span class="params">bits=<span class="number">1024</span></span>):</span><br><span class="line">    p = getPrime(bits)</span><br><span class="line">    q = getPrime(bits)</span><br><span class="line">    e = <span class="number">3</span>  </span><br><span class="line">    n = p * q</span><br><span class="line">    et = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> et % e == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;e和et不互素，需要重新生成p和q&quot;</span>)</span><br><span class="line">    d = invmod(e,et)</span><br><span class="line">    <span class="keyword">return</span> (e,n),(d,n)</span><br></pre></td></tr></table></figure><p>然后就是RSA的加密和解密函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">RSA_e</span>(<span class="params">m,public_key</span>):</span><br><span class="line">    e,n = public_key</span><br><span class="line">    c = <span class="built_in">pow</span>(m,e,n)</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">RSA_d</span>(<span class="params">c,private_key</span>):</span><br><span class="line">    d,n = private_key</span><br><span class="line">    m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line">    <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure><p>最后需要验证我们的函数，首先验证题目中提供对数字‘42’的加密和解密，编写如下主函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    public_key, private_key = generate_rsa_keys(bits=<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Public Key:&quot;</span>, public_key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Private Key:&quot;</span>, private_key)</span><br><span class="line">    m = <span class="number">42</span></span><br><span class="line">    c = RSA_e(m,public_key)</span><br><span class="line">    m = RSA_d(c,private_key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Encrypted message:&quot;</span>,c)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Decrypted message:&quot;</span>,m)</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Public Key: (3,18584674673132354443799672761999941195666000202227614111637155188539270102977177731778018459960150317179869096463577703162143774936243688426920345316552503579131340867655377725303228596377386065225388154913735169967323835455241628652156536489258197597460873974039760487200652925252344940958437709182291610007034125308781140179215153252229512228360941259630163260655799104054957802710229055844388887031905568258883483304070344807372760151934114113984889764718190341459171281490147513254095481591774318259828757818433860151920192737540296635075104425833323314600516252161361510537724590619394519884470682648995016113887)</span><br><span class="line">Private Key: (12389783115421569629199781841333294130444000134818409407758103459026180068651451821185345639973433544786579397642385135441429183290829125617946896877701669052754227245103585150202152397584924043483592103275823446644882556970161085768104357659505465064973915982693173658133768616834896627305625139454861073337838844392286656582400222672086962170281752665081946086647483823131098260696325149265363477667565205536882892789035367095109247178601111866806090173693393156455850235147511096016082968414410933328693661222516965388865455131890742039547494515108404863454559206641078024375171187968771304813410281675569739684491, 18584674673132354443799672761999941195666000202227614111637155188539270102977177731778018459960150317179869096463577703162143774936243688426920345316552503579131340867655377725303228596377386065225388154913735169967323835455241628652156536489258197597460873974039760487200652925252344940958437709182291610007034125308781140179215153252229512228360941259630163260655799104054957802710229055844388887031905568258883483304070344807372760151934114113984889764718190341459171281490147513254095481591774318259828757818433860151920192737540296635075104425833323314600516252161361510537724590619394519884470682648995016113887)</span><br><span class="line">Encrypted message: 74088</span><br><span class="line">Decrypted message: 42</span><br></pre></td></tr></table></figure><p>现在测试对一个字符串‘Happy Holloween!’的加解密结果，编写如下主函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    public_key, private_key = generate_rsa_keys(bits=<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Public Key:&quot;</span>, public_key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Private Key:&quot;</span>, private_key)</span><br><span class="line">    message = <span class="string">&quot;Happy Holloween!&quot;</span></span><br><span class="line">    m = <span class="built_in">int</span>.from_bytes(message.encode(<span class="string">&#x27;utf-8&#x27;</span>), byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    c = RSA_e(m,public_key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Encrypted message:&quot;</span>,c)</span><br><span class="line">    m = RSA_d(c,private_key)</span><br><span class="line">    message = m.to_bytes((m.bit_length() + <span class="number">7</span>) // <span class="number">8</span>, byteorder=<span class="string">&#x27;big&#x27;</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Decrypted message:&quot;</span>,message)</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Public Key: (3, 18746808571300120504075819075682594108587535388098754677870678403048294162399846334137445538730775144599084227460865632005107133341672067110771050673013583813667197683875501302973912467166141154341320814285678147761034215354099126591602306404085973955963843526566924290314499362955841196440900414874353607804365254706041430929565530836774408396058906536328668430766073670852859439307267025218730395514185697403199973733802260324197180412572479037624518165071365862506194984607606206276475436694257745689639894210738259160828771680605477570068261833446369430881080564601723636695474262854104359084128262572628557179013)</span><br><span class="line">Private Key: (12497872380866747002717212717121729405725023592065836451913785602032196108266564222758297025820516763066056151640577088003404755561114711407180700448675722542444798455917000868649274978110760769560880542857118765174022810236066084394401537602723982637309229017711282860209666241970560797627266943249569071869393919769818227415018394576223101062948188806376352414567503277949919018535889622512491130511685307096516768916314421416945739691371071076417554540102038686665301000050159474220726679317018289250423738605246696532022745489211634236528769821582503745462361003025656079851791180146414307639207005583822966476907, 18746808571300120504075819075682594108587535388098754677870678403048294162399846334137445538730775144599084227460865632005107133341672067110771050673013583813667197683875501302973912467166141154341320814285678147761034215354099126591602306404085973955963843526566924290314499362955841196440900414874353607804365254706041430929565530836774408396058906536328668430766073670852859439307267025218730395514185697403199973733802260324197180412572479037624518165071365862506194984607606206276475436694257745689639894210738259160828771680605477570068261833446369430881080564601723636695474262854104359084128262572628557179013)</span><br><span class="line">Encrypted message: 890564482417655822788709386116389927760915707730126623223467631024461475735568125139054708085662317206414437078625</span><br><span class="line">Decrypted message: Happy Holloween!</span><br></pre></td></tr></table></figure><h2 id="实验总结">实验总结</h2><p>本次实验我充分了解了RSA算法的运行过程，并且更加熟悉了运用公钥和私钥加解密的程序编写。在第一个实验里面复习了计算解个数的公式。在第二个实验里面我起初的运行速度很慢，后来仔细读题发现模逆运算中面对大素数的运算开销很大需要运用欧几里得算法来减少时间复杂度。在实验二对字符串加解密的时候需要把字符串中的字节转换为整数再进行运算。最后解密时需要把整数转换为二进制向上取整进而算出需要多少个字节表示，再把整数转换为字节数组再将字节数组解码为 UTF-8 编码的字符串得到最终答案。</p><h2 id="源代码连接">源代码连接</h2><p><a href="https://github.com/cool-chicken/cryptography-exp/tree/main/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C%E4%B8%89">https://github.com/cool-chicken/cryptography-exp/tree/main/密码学实验三</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-crypto-2</title>
      <link href="/2024/10/14/my-crypto-2/"/>
      <url>/2024/10/14/my-crypto-2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-European-ePassport">1.European ePassport</h2><p>MTC3 AES key — encoded in the machine readable zone of a European ePassport (<a href="https://www.mysterytwisterc3.org/en/challenges/level-2/aes-key--encoded-in-the-machine-readable-zone-of-a-european-epassport">link</a>)<br>题目需要破解一个欧洲护照，图片中给出了护照的一部分内容，和一个未知字符。已知初始化矢量即IV为零，填充为01-00。所以首先我们需要找到缺失的字符是什么。根据规则定义了<code>unknown_number()</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unknown_number</span>():</span><br><span class="line">    number = <span class="string">&quot;111116&quot;</span></span><br><span class="line">    weight = <span class="string">&quot;731&quot;</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(number)):</span><br><span class="line">        total += <span class="built_in">int</span>(number[i]) * <span class="built_in">int</span>(weight[i % <span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span> total % <span class="number">10</span>  <span class="comment">#7</span></span><br></pre></td></tr></table></figure><p>经过调用函数我们找到缺失的字符是<code>7</code>所以我们能够补齐护照得到<code>12345678&lt;8&lt;&lt;&lt;1110182&lt;1111167&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;4</code>。然后我们利用这个护照序列<br>计算出k_seed。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_kseed</span>():</span><br><span class="line">    MRZ_information = <span class="string">&quot;12345678&lt;8&lt;&lt;&lt;1110182&lt;1111167&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;4&quot;</span></span><br><span class="line">    H_information = hashlib.sha1((MRZ_information[:<span class="number">10</span>] + MRZ_information[<span class="number">13</span>:<span class="number">20</span>] + MRZ_information[<span class="number">21</span>:<span class="number">28</span>]).encode()).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> H_information[:<span class="number">32</span>]</span><br></pre></td></tr></table></figure><p>从 K_seed 计算出 Ka 和 Kb</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_ka_kb</span>(<span class="params">K_seed</span>):</span><br><span class="line">    d = K_seed + <span class="string">&quot;00000001&quot;</span></span><br><span class="line">    H_d = hashlib.sha1(binascii.unhexlify(d)).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> H_d[:<span class="number">16</span>], H_d[<span class="number">16</span>:<span class="number">32</span>]</span><br></pre></td></tr></table></figure><p>分别对Ka和Kb进行奇偶校验</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parity_check</span>(<span class="params">hex_str</span>):</span><br><span class="line">    binary_str = <span class="built_in">bin</span>(<span class="built_in">int</span>(hex_str, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">64</span>)</span><br><span class="line">    k_list = [(byte := binary_str[i:i + <span class="number">7</span>]) + (<span class="string">&#x27;1&#x27;</span> <span class="keyword">if</span> byte.count(<span class="string">&#x27;1&#x27;</span>) % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(binary_str), <span class="number">8</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hex</span>(<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(k_list), <span class="number">2</span>))[<span class="number">2</span>:].zfill(<span class="number">16</span>)</span><br></pre></td></tr></table></figure><p>得到key之后解密密文删掉填充得到<strong>最终答案</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Key: ea8645d97ff725a898942aa280c43179</span><br><span class="line">Decrypted message: Herzlichen Glueckwunsch. Sie haben die Nuss geknackt. Das Codewort lautet: Kryptographie!</span><br></pre></td></tr></table></figure><h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">text</span>):</span><br><span class="line">    padding_len = AES.block_size - <span class="built_in">len</span>(text) % AES.block_size</span><br><span class="line">    padding = <span class="string">b&#x27;\x01&#x27;</span> + <span class="string">b&#x27;\x00&#x27;</span> * (padding_len - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> text + padding</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unpad</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">return</span> text.rstrip(<span class="string">b&#x27;\x00&#x27;</span>).rstrip(<span class="string">b&#x27;\x01&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unknown_number</span>():</span><br><span class="line">    number = <span class="string">&quot;111116&quot;</span></span><br><span class="line">    weight = <span class="string">&quot;731&quot;</span></span><br><span class="line">    total = <span class="built_in">sum</span>(<span class="built_in">int</span>(number[i]) * <span class="built_in">int</span>(weight[i % <span class="number">3</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(number)))</span><br><span class="line">    <span class="keyword">return</span> total % <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_kseed</span>():</span><br><span class="line">    MRZ_information = <span class="string">&quot;12345678&lt;8&lt;&lt;&lt;1110182&lt;1111167&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;4&quot;</span></span><br><span class="line">    H_information = hashlib.sha1((MRZ_information[:<span class="number">10</span>] + MRZ_information[<span class="number">13</span>:<span class="number">20</span>] + MRZ_information[<span class="number">21</span>:<span class="number">28</span>]).encode()).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> H_information[:<span class="number">32</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_ka_kb</span>(<span class="params">K_seed</span>):</span><br><span class="line">    d = K_seed + <span class="string">&quot;00000001&quot;</span></span><br><span class="line">    H_d = hashlib.sha1(binascii.unhexlify(d)).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> H_d[:<span class="number">16</span>], H_d[<span class="number">16</span>:<span class="number">32</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parity_check</span>(<span class="params">hex_str</span>):</span><br><span class="line">    binary_str = <span class="built_in">bin</span>(<span class="built_in">int</span>(hex_str, <span class="number">16</span>))[<span class="number">2</span>:].zfill(<span class="number">64</span>)</span><br><span class="line">    k_list = [(byte := binary_str[i:i + <span class="number">7</span>]) + (<span class="string">&#x27;1&#x27;</span> <span class="keyword">if</span> byte.count(<span class="string">&#x27;1&#x27;</span>) % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;0&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(binary_str), <span class="number">8</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hex</span>(<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(k_list), <span class="number">2</span>))[<span class="number">2</span>:].zfill(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_message</span>(<span class="params">encrypted_text</span>):</span><br><span class="line">    K_seed = calculate_kseed()</span><br><span class="line">    ka, kb = calculate_ka_kb(K_seed)</span><br><span class="line">    key = parity_check(ka) + parity_check(kb)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Key: <span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ciphertext = base64.b64decode(encrypted_text)</span><br><span class="line">    IV = <span class="string">&#x27;0&#x27;</span> * <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    cipher = AES.new(binascii.unhexlify(key), AES.MODE_CBC, binascii.unhexlify(IV))</span><br><span class="line">    decrypted_padded = cipher.decrypt(ciphertext)</span><br><span class="line">    decrypted_message = unpad(decrypted_padded).decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Decrypted message: <span class="subst">&#123;decrypted_message&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(unknown_number())</span><br><span class="line">    encrypted_text = <span class="string">&#x27;9MgYwmuPrjiecPMx61O6zIuy3MtIXQQ0E59T3xB6u0Gyf1gYs2i3K9Jxaa0zj4gTMazJuApwd6+jdyeI5iGHvhQyDHGVlAuYTgJrbFDrfB22Fpil2NfNnWFBTXyf7SDI&#x27;</span></span><br><span class="line">    decrypt_message(encrypted_text)</span><br></pre></td></tr></table></figure><h2 id="2-Crypto-Challenge-Set-2">2. Crypto Challenge Set 2</h2><h3 id="1-Implement-PKCS-7-padding">(1)Implement PKCS#7 padding</h3><p>如题目所述就是应用PKCS#7这种填充方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pkcs7_pad</span>(<span class="params">text, block_size</span>):</span><br><span class="line">    padding_len = block_size - (<span class="built_in">len</span>(text) % block_size)</span><br><span class="line">    padding = <span class="built_in">bytes</span>([padding_len] * padding_len)</span><br><span class="line">    <span class="keyword">return</span> text + padding</span><br></pre></td></tr></table></figure><h3 id="2-Implement-CBC-mode">(2)Implement CBC mode</h3><p>首先需要按照题目所述写一个ECB函数如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ecb_decrypt</span>(<span class="params">cipher_text, key</span>):</span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.decrypt(cipher_text)</span><br></pre></td></tr></table></figure><p>因为这个是基于CBC的密码所以说要写一个解密CBC的函数并且输出去除PKCS#7填充的明文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cbc_decrypt</span>(<span class="params">cipher_text, key, iv</span>):</span><br><span class="line">    block_size = <span class="built_in">len</span>(key)</span><br><span class="line">    plain_text = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    previous_block = iv</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(cipher_text), block_size):</span><br><span class="line">        block = cipher_text[i:i + block_size]</span><br><span class="line">        decrypted_block = ecb_decrypt(block, key)</span><br><span class="line">        decrypted_block = xor_bytes(decrypted_block, previous_block)</span><br><span class="line">        plain_text += decrypted_block</span><br><span class="line">        previous_block = block</span><br><span class="line">    <span class="keyword">return</span> pkcs7_unpad(plain_text)</span><br></pre></td></tr></table></figure><p>最后写出我们的 <code>main</code>函数运算，输入已知的key<code>'YELLOW SUBMARINE'</code>和16位空IV<br>以及读取密文文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    key = <span class="string">b&#x27;YELLOW SUBMARINE&#x27;</span></span><br><span class="line">    iv = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">16</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;2_2.txt&quot;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        ciphertext = base64.b64decode(f.read())</span><br><span class="line">    plain_text = cbc_decrypt(ciphertext, key, iv)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;plaintext: <span class="subst">&#123;plain_text.decode()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>通过调用函数能够得到<strong>最终答案</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m back and I&#x27;m ringin&#x27; the bell </span><br><span class="line">A rockin&#x27; on the mike while the fly girls yell </span><br><span class="line">In ecstasy in the back of me </span><br><span class="line">Well that&#x27;s my DJ Deshay cuttin&#x27; all them Z&#x27;s </span><br><span class="line">Hittin&#x27; hard and the girlies goin&#x27; crazy </span><br><span class="line">Vanilla&#x27;s on the mike, man I&#x27;m not lazy. </span><br><span class="line"></span><br><span class="line">I&#x27;m lettin&#x27; my drug kick in </span><br><span class="line">It controls my mouth and I begin </span><br><span class="line">To just let it flow, let my concepts go </span><br><span class="line">My posse&#x27;s to the side yellin&#x27;, Go Vanilla Go! </span><br><span class="line"></span><br><span class="line">Smooth &#x27;cause that&#x27;s the way I will be </span><br><span class="line">And if you don&#x27;t give a damn, then </span><br><span class="line">Why you starin&#x27; at me </span><br><span class="line">So get off &#x27;cause I control the stage </span><br><span class="line">There&#x27;s no dissin&#x27; allowed </span><br><span class="line">I&#x27;m in my own phase </span><br><span class="line">The girlies sa y they love me and that is ok </span><br><span class="line">And I can dance better than any kid n&#x27; play </span><br><span class="line"></span><br><span class="line">Stage 2 -- Yea the one ya&#x27; wanna listen to </span><br><span class="line">It&#x27;s off my head so let the beat play through </span><br><span class="line">So I can funk it up and make it sound good </span><br><span class="line">1-2-3 Yo -- Knock on some wood </span><br><span class="line">For good luck, I like my rhymes atrocious </span><br><span class="line">Supercalafragilisticexpialidocious </span><br><span class="line">I&#x27;m an effect and that you can bet </span><br><span class="line">I can take a fly girl and make her wet. </span><br><span class="line"></span><br><span class="line">I&#x27;m like Samson -- Samson to Delilah </span><br><span class="line">There&#x27;s no denyin&#x27;, You can try to hang </span><br><span class="line">But you&#x27;ll keep tryin&#x27; to get my style </span><br><span class="line">Over and over, practice makes perfect </span><br><span class="line">But not if you&#x27;re a loafer. </span><br><span class="line"></span><br><span class="line">You&#x27;ll get nowhere, no place, no time, no girls </span><br><span class="line">Soon -- Oh my God, homebody, you probably eat </span><br><span class="line">Spaghetti with a spoon! Come on and say it! </span><br><span class="line"></span><br><span class="line">VIP. Vanilla Ice yep, yep, I&#x27;m comin&#x27; hard like a rhino </span><br><span class="line">Intoxicating so you stagger like a wino </span><br><span class="line">So punks stop trying and girl stop cryin&#x27; </span><br><span class="line">Vanilla Ice is sellin&#x27; and you people are buyin&#x27; </span><br><span class="line">&#x27;Cause why the freaks are jockin&#x27; like Crazy Glue </span><br><span class="line">Movin&#x27; and groovin&#x27; trying to sing along </span><br><span class="line">All through the ghetto groovin&#x27; this here song </span><br><span class="line">Now you&#x27;re amazed by the VIP posse. </span><br><span class="line"></span><br><span class="line">Steppin&#x27; so hard like a German Nazi </span><br><span class="line">Startled by the bases hittin&#x27; ground </span><br><span class="line">There&#x27;s no trippin&#x27; on mine, I&#x27;m just gettin&#x27; down </span><br><span class="line">Sparkamatic, I&#x27;m hangin&#x27; tight like a fanatic </span><br><span class="line">You trapped me once and I thought that </span><br><span class="line">You might have it </span><br><span class="line">So step down and lend me your ear </span><br><span class="line">&#x27;89 in my time! You, &#x27;90 is my year. </span><br><span class="line"></span><br><span class="line">You&#x27;re weakenin&#x27; fast, YO! and I can tell it </span><br><span class="line">Your body&#x27;s gettin&#x27; hot, so, so I can smell it </span><br><span class="line">So don&#x27;t be mad and don&#x27;t be sad </span><br><span class="line">&#x27;Cause the lyrics belong to ICE, You can call me Dad </span><br><span class="line">You&#x27;re pitchin&#x27; a fit, so step back and endure </span><br><span class="line">Let the witch doctor, Ice, do the dance to cure </span><br><span class="line">So come up close and don&#x27;t be square </span><br><span class="line">You wanna battle me -- Anytime, anywhere </span><br><span class="line"></span><br><span class="line">You thought that I was weak, Boy, you&#x27;re dead wrong </span><br><span class="line">So come on, everybody and sing this song </span><br><span class="line"></span><br><span class="line">Say -- Play that funky music Say, go white boy, go white boy go </span><br><span class="line">play that funky music Go white boy, go white boy, go </span><br><span class="line">Lay down and boogie and play that funky music till you die. </span><br><span class="line"></span><br><span class="line">Play that funky music Come on, Come on, let me hear </span><br><span class="line">Play that funky music white boy you say it, say it </span><br><span class="line">Play that funky music A little louder now </span><br><span class="line">Play that funky music, white boy Come on, Come on, Come on </span><br><span class="line">Play that funky music</span><br></pre></td></tr></table></figure><p>（（（貌似是一段歌词</p><h3 id="3-An-ECB-CBC-detection-oracle">(3)An ECB/CBC detection oracle</h3><p>按照题目意思首先生成随机AES密钥。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_random_aes_key</span>():</span><br><span class="line">    <span class="keyword">return</span> os.urandom(<span class="number">16</span>)</span><br></pre></td></tr></table></figure><p>之后创建一个加密oracle，在明文之前和之后附加随机字节，然后使用ECB或CBC模式随机加密。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">encryption_oracle</span>(<span class="params">input_data</span>):</span><br><span class="line">    key = generate_random_aes_key()</span><br><span class="line">    prepend = os.urandom(random.randint(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">    append = os.urandom(random.randint(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">    plain_text = prepend + input_data + append</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span>:<span class="comment"># 使用ECB模式</span></span><br><span class="line">        cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">        padded_text = pkcs7_pad(plain_text, AES.block_size)</span><br><span class="line">        encrypted = cipher.encrypt(padded_text)</span><br><span class="line">        mode = <span class="string">&quot;ECB&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:<span class="comment"># 使用CBC模式</span></span><br><span class="line">        iv = os.urandom(AES.block_size)</span><br><span class="line">        encrypted = cbc_encrypt(plain_text, key, iv)</span><br><span class="line">        mode = <span class="string">&quot;CBC&quot;</span></span><br><span class="line">    <span class="keyword">return</span> encrypted, mode</span><br></pre></td></tr></table></figure><p>最后编写一个函数来检测使用的加密模式是ECB还是CBC，这里用在ECB模式下，相同的明文块会生成相同的密文块而CBC模式下，每个明文块在加密前会与前一个密文块进行异或操作，使得相同的明文块生成不同的密文块。所以运用这个不同来判断是什么模式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detect_encryption_mode</span>(<span class="params">encrypted_data</span>):</span><br><span class="line">    block_size = AES.block_size</span><br><span class="line">    blocks = [encrypted_data[i:i + block_size] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(encrypted_data), block_size)]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(blocks)) != <span class="built_in">len</span>(blocks):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ECB&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CBC&quot;</span></span><br></pre></td></tr></table></figure><p>最后调用<code>main</code>函数，这里的明文是三块一样的就可以用上吗的方法判断了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    key = <span class="string">b&#x27;YELLOW SUBMARINE&#x27;</span></span><br><span class="line">    iv = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">16</span> * <span class="number">3</span></span><br><span class="line">    plain_text = <span class="string">b&quot;\xFF&quot;</span> * <span class="number">16</span> * <span class="number">3</span></span><br><span class="line">    encrypted, mode = encryption_oracle(plain_text)</span><br><span class="line">    detected_mode = detect_encryption_mode(encrypted)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Actual mode: <span class="subst">&#123;mode&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Detected mode: <span class="subst">&#123;detected_mode&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-Byte-at-a-time-ECB-decryption-Simple">(4)Byte-at-a-time ECB decryption (Simple)</h3><p>就是攻击函数就是写一堆A然后把不知道的放在最后，像这样“AAAT”A已知T未知的数据块进行加密，并将得到的密文存储。然后，你向oracle请求加密“AAAi”的数据块识别第一个目标字节，当返回的密文与之前存储密文相同时，知道字节i就是目标字节T。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto <span class="keyword">import</span> Random</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">UNKNOWN_STRING = base64.b64decode(</span><br><span class="line">    <span class="string">b&quot;Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg&quot;</span></span><br><span class="line">    <span class="string">b&quot;aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq&quot;</span></span><br><span class="line">    <span class="string">b&quot;dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg&quot;</span></span><br><span class="line">    <span class="string">b&quot;YnkK&quot;</span></span><br><span class="line">)</span><br><span class="line">KEY = Random.new().read(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">data, block_size=<span class="number">16</span></span>):</span><br><span class="line">    padding_len = block_size - <span class="built_in">len</span>(data) % block_size</span><br><span class="line">    <span class="keyword">return</span> data + <span class="built_in">bytes</span>([padding_len] * padding_len)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encryption_oracle</span>(<span class="params">your_string</span>):</span><br><span class="line">    plaintext = pad(your_string + UNKNOWN_STRING)</span><br><span class="line">    cipher = AES.new(KEY, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.encrypt(plaintext)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_block_size</span>():</span><br><span class="line">    initial_len = <span class="built_in">len</span>(encryption_oracle(<span class="string">b&quot;&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">256</span>):</span><br><span class="line">        data = <span class="string">b&quot;A&quot;</span> * i</span><br><span class="line">        new_len = <span class="built_in">len</span>(encryption_oracle(data))</span><br><span class="line">        <span class="keyword">if</span> new_len != initial_len:</span><br><span class="line">            <span class="keyword">return</span> new_len - initial_len</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_mode</span>(<span class="params">cipher</span>):</span><br><span class="line">    block_size = <span class="number">16</span></span><br><span class="line">    blocks = [cipher[i:i + block_size] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(cipher), block_size)]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ECB&quot;</span> <span class="keyword">if</span> <span class="built_in">len</span>(blocks) &gt; <span class="built_in">len</span>(<span class="built_in">set</span>(blocks)) <span class="keyword">else</span> <span class="string">&quot;not ECB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ecb_decrypt</span>(<span class="params">block_size</span>):</span><br><span class="line">    known_bytes = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        block_index = <span class="built_in">len</span>(known_bytes) // block_size</span><br><span class="line">        block_offset = block_size - <span class="number">1</span> - (<span class="built_in">len</span>(known_bytes) % block_size)</span><br><span class="line">        prefix = <span class="string">b&quot;A&quot;</span> * block_offset</span><br><span class="line">        target_block = encryption_oracle(prefix)[: (block_index + <span class="number">1</span>) * block_size]</span><br><span class="line"></span><br><span class="line">        found = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            guess = prefix + known_bytes + <span class="built_in">bytes</span>([i])</span><br><span class="line">            <span class="keyword">if</span> encryption_oracle(guess)[: (block_index + <span class="number">1</span>) * block_size] == target_block:</span><br><span class="line">                known_bytes += <span class="built_in">bytes</span>([i])</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Decrypted text: <span class="subst">&#123;known_bytes.decode(<span class="string">&#x27;ascii&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    block_size = detect_block_size()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Detected block size: <span class="subst">&#123;block_size&#125;</span>&quot;</span>)</span><br><span class="line">    cipher = encryption_oracle(<span class="string">b&quot;A&quot;</span> * <span class="number">50</span>)</span><br><span class="line">    mode = detect_mode(cipher)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Detected mode: <span class="subst">&#123;mode&#125;</span>&quot;</span>)</span><br><span class="line">    ecb_decrypt(block_size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rollin&#x27; in my 5.0</span><br><span class="line">With my rag-top down so my hair can blow</span><br><span class="line">The girlies on standby waving just to say hi</span><br><span class="line">Did you stop? No, I just drove by</span><br></pre></td></tr></table></figure><h3 id="5-ECB-cut-and-paste">(5)ECB cut-and-paste</h3><p>这个题就是读取这个信息然后能够把有用的信息提出来比如email、uid等信息<br>我在这里设置了自动生成的密钥，在给定信息后加密、解密、然后打印识别的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> get_random_bytes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_kv</span>(<span class="params">kv_string</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(pair.split(<span class="string">&#x27;=&#x27;</span>) <span class="keyword">for</span> pair <span class="keyword">in</span> kv_string.split(<span class="string">&#x27;&amp;&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">profile_for</span>(<span class="params">email</span>):</span><br><span class="line">    email = re.sub(<span class="string">r&#x27;[&amp;=]&#x27;</span>, <span class="string">&#x27;&#x27;</span>, email)</span><br><span class="line">    profile = &#123;</span><br><span class="line">        <span class="string">&#x27;email&#x27;</span>: email,</span><br><span class="line">        <span class="string">&#x27;uid&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">&#x27;role&#x27;</span>: <span class="string">&#x27;user&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;email=<span class="subst">&#123;profile[<span class="string">&#x27;email&#x27;</span>]&#125;</span>&amp;uid=<span class="subst">&#123;profile[<span class="string">&#x27;uid&#x27;</span>]&#125;</span>&amp;role=<span class="subst">&#123;profile[<span class="string">&#x27;role&#x27;</span>]&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">data</span>):</span><br><span class="line">    block_size = <span class="number">16</span></span><br><span class="line">    padding = block_size - <span class="built_in">len</span>(data) % block_size</span><br><span class="line">    <span class="keyword">return</span> data + <span class="built_in">bytes</span>([padding] * padding)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">unpad</span>(<span class="params">data</span>):</span><br><span class="line">    padding = data[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> data[:-padding]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_key</span>():</span><br><span class="line">    <span class="keyword">return</span> get_random_bytes(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_profile</span>(<span class="params">profile, key</span>):</span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    padded_profile = pad(profile.encode())</span><br><span class="line">    <span class="keyword">return</span> cipher.encrypt(padded_profile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_profile</span>(<span class="params">ciphertext, key</span>):</span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    decrypted = unpad(cipher.decrypt(ciphertext))</span><br><span class="line">    <span class="keyword">return</span> decrypted.decode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_admin_profile</span>():</span><br><span class="line">    key = generate_key()</span><br><span class="line">    email1 = <span class="string">&quot;foo@bar.com&quot;</span></span><br><span class="line">    email2 = <span class="string">&quot;foo@bar.comadmin&quot;</span> + <span class="string">&quot;\x0b&quot;</span> * <span class="number">11</span>  </span><br><span class="line"></span><br><span class="line">    encrypted1 = encrypt_profile(profile_for(email1), key)</span><br><span class="line">    encrypted2 = encrypt_profile(profile_for(email2), key)</span><br><span class="line">    crafted_ciphertext = encrypted1[:<span class="number">32</span>] + encrypted2[<span class="number">16</span>:<span class="number">32</span>]</span><br><span class="line"></span><br><span class="line">    decrypted_profile = decrypt_profile(crafted_ciphertext, key)</span><br><span class="line">    <span class="keyword">return</span> parse_kv(decrypted_profile)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(parse_kv(<span class="string">&quot;foo=bar&amp;baz=qux&amp;zap=zazzle&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(profile_for(<span class="string">&quot;foo@bar.com&quot;</span>))</span><br><span class="line">    key = generate_key()</span><br><span class="line">    encrypted = encrypt_profile(profile_for(<span class="string">&quot;foo@bar.com&quot;</span>), key)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(decrypt_profile(encrypted, key))</span><br><span class="line">    <span class="built_in">print</span>(create_admin_profile())</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;foo&#x27;: &#x27;bar&#x27;, &#x27;baz&#x27;: &#x27;qux&#x27;, &#x27;zap&#x27;: &#x27;zazzle&#x27;&#125;</span><br><span class="line">email=foo@bar.com&amp;uid=10&amp;role=user</span><br><span class="line">---------------------------------</span><br><span class="line">email=foo@bar.com&amp;uid=10&amp;role=user</span><br><span class="line">&#123;&#x27;email&#x27;: &#x27;foo@bar.com&#x27;, &#x27;uid&#x27;: &#x27;10&#x27;, &#x27;role&#x27;: &#x27;usmadmi&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Byte-at-a-time-ECB-decryption-Harder">(6)Byte-at-a-time ECB decryption (Harder)</h3><p>随机前缀的长度是不确定的，所以说我们首先需要确定前缀的长度。<br>由于有一个随机前缀，在逐渐增加输入的过程中，某一段的密文会变得稳定，这表示该块已完全由前缀和我们构造的输入组成。然后其他的和前面那个simple是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> Padding</span><br><span class="line"></span><br><span class="line">key = os.urandom(<span class="number">16</span>)</span><br><span class="line">prefix = os.urandom(randint(<span class="number">1</span>, <span class="number">15</span>))</span><br><span class="line">target = base64.b64decode(</span><br><span class="line">            <span class="string">&quot;Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg&quot;</span></span><br><span class="line">            <span class="string">&quot;aGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq&quot;</span></span><br><span class="line">            <span class="string">&quot;dXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg&quot;</span></span><br><span class="line">            <span class="string">&quot;YnkK&quot;</span></span><br><span class="line">        )</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">message</span>):</span><br><span class="line">    plaintext = Padding.pad(prefix + message + target, <span class="number">16</span>)</span><br><span class="line">    cipher = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> cipher.encrypt(plaintext)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Finding the block size</span></span><br><span class="line">previous_length = <span class="built_in">len</span>(encrypt(<span class="string">b&#x27;&#x27;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(encrypt(<span class="string">b&#x27;X&#x27;</span> * i))</span><br><span class="line">    <span class="keyword">if</span> length != previous_length:</span><br><span class="line">        block_size = length - previous_length</span><br><span class="line">        size_prefix_plus_target_aligned = previous_length</span><br><span class="line">        min_known_ptxt_size_to_align = i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;did not detect any change in ciphertext length&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> block_size == <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Finding the prefix size</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_bytes_in_blocks</span>(<span class="params">data, block_size</span>):</span><br><span class="line">    <span class="keyword">return</span> [data[i:i + block_size] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), block_size)]</span><br><span class="line"></span><br><span class="line">previous_blocks = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, block_size + <span class="number">1</span>):</span><br><span class="line">    blocks = split_bytes_in_blocks(encrypt(<span class="string">b&#x27;X&#x27;</span> * i), block_size)</span><br><span class="line">    <span class="keyword">if</span> previous_blocks <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> blocks[<span class="number">0</span>] == previous_blocks[<span class="number">0</span>]:</span><br><span class="line">        prefix_size = block_size - i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    previous_blocks = blocks</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&#x27;did not detect constant ciphertext block&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> prefix_size == <span class="built_in">len</span>(prefix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute the size of the target</span></span><br><span class="line">target_size = size_prefix_plus_target_aligned - min_known_ptxt_size_to_align - prefix_size</span><br><span class="line"><span class="keyword">assert</span> target_size == <span class="built_in">len</span>(target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decrypt the target bytes</span></span><br><span class="line">known_target_bytes = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(target_size):</span><br><span class="line">    r = prefix_size</span><br><span class="line">    k = <span class="built_in">len</span>(known_target_bytes)</span><br><span class="line">    padding_length = (-k - <span class="number">1</span> - r) % block_size</span><br><span class="line">    padding = <span class="string">b&quot;X&quot;</span> * padding_length</span><br><span class="line"></span><br><span class="line">    target_block_number = (k + r) // block_size</span><br><span class="line">    target_slice = <span class="built_in">slice</span>(target_block_number * block_size, (target_block_number + <span class="number">1</span>) * block_size)</span><br><span class="line">    target_block = encrypt(padding)[target_slice]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        message = padding + known_target_bytes + <span class="built_in">bytes</span>([i])</span><br><span class="line">        block = encrypt(message)[target_slice]</span><br><span class="line">        <span class="keyword">if</span> block == target_block:</span><br><span class="line">            known_target_bytes += <span class="built_in">bytes</span>([i])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(known_target_bytes.decode())</span><br></pre></td></tr></table></figure><p>答案是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rollin&#x27; in my 5.0</span><br><span class="line">With my rag-top down so my hair can blow</span><br><span class="line">The girlies on standby waving just to say hi</span><br><span class="line">Did you stop? No, I just drove by</span><br></pre></td></tr></table></figure><h3 id="7-PKCS-7-padding-validation">(7)PKCS#7 padding validation</h3><p>这个就写几个PKCS#7的测试就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">validate_and_strip_pkcs7_padding</span>(<span class="params">plaintext</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> plaintext:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;The plaintext is empty&quot;</span>)</span><br><span class="line"></span><br><span class="line">    padding_value = plaintext[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> padding_value &lt; <span class="number">1</span> <span class="keyword">or</span> padding_value &gt; <span class="number">16</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid padding value&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> plaintext[-padding_value:] != <span class="built_in">bytes</span>([padding_value]) * padding_value:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid PKCS#7 padding&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> plaintext[:-padding_value]</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = validate_and_strip_pkcs7_padding(<span class="string">b&quot;ICE ICE BABY\x04\x04\x04\x04&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result.decode())  <span class="comment"># output: ICE ICE BABY</span></span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = validate_and_strip_pkcs7_padding(<span class="string">b&quot;ICE ICE BABY\x05\x05\x05\x05&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result.decode())</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># output: Invalid PKCS#7 padding</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = validate_and_strip_pkcs7_padding(<span class="string">b&quot;ICE ICE BABY\x01\x02\x03\x04&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result.decode())</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># output: Invalid PKCS#7 padding</span></span><br></pre></td></tr></table></figure><h3 id="8-CBC-bit-flipping-attacks">(8)CBC bit flipping attacks</h3><p>我们要让<code>;admin=true;</code>出现在消息中但是不可以用&quot;;“或”=&quot;，所以说设置<code>sanitize_input</code>函数将输入中的 ‘;’ 和 ‘=’ 字符转义成对应的16进制表示，防止用户直接输入<code>;admin=true;</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sanitize_input</span>(<span class="params">userdata</span>):</span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">r&#x27;[;=]&#x27;</span>, <span class="keyword">lambda</span> x: <span class="string">f&quot;%<span class="subst">&#123;<span class="built_in">ord</span>(x.group(<span class="number">0</span>)):02x&#125;</span>&quot;</span>, userdata)<span class="comment">#将字符转换为16进制</span></span><br></pre></td></tr></table></figure><p>然后接受用户的输入数据，首先将其转义，然后将它嵌入到一个固定的前缀和后缀之间，组成完整的明文。最后，该明文经过<code>AES CBC</code>模式加密后返回密文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">userdata</span>):</span><br><span class="line">    prefix = <span class="string">b&quot;comment1=cooking%20MCs;userdata=&quot;</span></span><br><span class="line">    suffix = <span class="string">b&quot;;comment2=%20like%20a%20pound%20of%20bacon&quot;</span></span><br><span class="line">    sanitized_userdata = sanitize_input(userdata.decode()).encode()</span><br><span class="line">    plaintext = prefix + sanitized_userdata + suffix</span><br><span class="line">    padded_plaintext = pad(plaintext)</span><br><span class="line">    cipher = AES.new(KEY, AES.MODE_CBC, IV)</span><br><span class="line">    ciphertext = cipher.encrypt(padded_plaintext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Plaintext: <span class="subst">&#123;plaintext&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> ciphertext</span><br></pre></td></tr></table></figure><p>生成一个初始的密文16个字母A。定位我们希望进行位翻转的区域，通过亦或运算操作修改密文的第二个块这将影响解密出的第三个块的明文。而我们希望将明文中的16个字母A变成 <code>;admin=true;</code>所以编写翻转攻击函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bitflipping_attack</span>():</span><br><span class="line">    <span class="comment"># 生成初始的密文</span></span><br><span class="line">    userdata = <span class="string">b&quot;A&quot;</span> * <span class="number">16</span></span><br><span class="line">    ciphertext = encrypt(userdata)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Ciphertext: <span class="subst">&#123;ciphertext&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改密文以注入 &quot;;admin=true;&quot;</span></span><br><span class="line">    block_size = <span class="number">16</span></span><br><span class="line">    modified_ciphertext = <span class="built_in">bytearray</span>(ciphertext)</span><br><span class="line">    target = <span class="string">b&quot;;admin=true;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target)):</span><br><span class="line">        modified_ciphertext[block_size + i] ^= <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) ^ target[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查修改后的密文是否包含 &quot;;admin=true;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> decrypt(<span class="built_in">bytes</span>(modified_ciphertext))</span><br></pre></td></tr></table></figure><p>最后运行出来的答案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Plaintext: b&#x27;comment1=cooking%20MCs;userdata=AAAAAAAAAAAAAAAA;comment2=%20like%20a%20pound%20of%20bacon&#x27;</span><br><span class="line">Ciphertext: b&quot;\x1e^H\xec\xfen\xa8\x90\xf0\xae&amp;j\x9a&lt;\x1a\x03\xc7!4\x7f[\xce\xf5\xcc~GC)\xaeA\x15\xd2\xd0\xefz\xdf##\x11\xaf\xdaOP\x1albKi\xc4\x80#\x00\xa1\x18s\xf2\xec%\x11\x0f\xba&#x27;\xf6\xca\x16e\xd6\xddxJU\xf1\x1c\xda\x8b\xado\xe5\n\xfa\x83&#x27;1\x01\xe8;\x0e\n\x84/\xbf\x14\xf9\x93\x1f\xac&quot;</span><br><span class="line">Decrypted: b&#x27;comment1=cooking\x19yD\xf4*p\xd9B\xd1\xde\x08#\x8cb\x9b\xaf;admin=true;AAAA;comment2=%20like%20a%20pound%20of%20bacon&#x27;</span><br><span class="line">Bitflipping attack successful: True</span><br></pre></td></tr></table></figure><h2 id="实验总结">实验总结</h2><p>在这次密码实验中，我实现了多个重要的加密功能和攻击，包括 <strong>PKCS#7 填充</strong>、<strong>ECB/CBC 检测</strong>、<strong>逐字节 ECB 解密（简单与复杂版）</strong>、以及 <strong>CBC 位翻转攻击</strong>等多个实验。通过这些实验，我对加密算法AES运用更加熟练，也了解到CBC模式下的位翻转攻击以及ECB模式的可预测性也就是漏洞。我知道了，加密不仅要保证数据的机密性，还必须结合完整性验证等手段，才能有效防御攻击者的篡改和攻击。</p><h2 id="源代码链接">源代码链接</h2><p><a href="https://github.com/cool-chicken/cryptography-exp/tree/main/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C%E4%BA%8C">https://github.com/cool-chicken/cryptography-exp/tree/main/密码学实验二</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/10/12/hello-world/"/>
      <url>/2024/10/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my crypto-1</title>
      <link href="/2024/10/12/my-crypto-1/"/>
      <url>/2024/10/12/my-crypto-1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Many-Time-Pad">1. Many Time Pad</h2><p>Coursera Dan Boneh Week 1 Program Assignment（<a href="https://www.coursera.org/learn/crypto/quiz/KZ9js/week-1-programming-assignment-optional">link</a>）</p><h3 id="题目分析">题目分析</h3><p>题目中11个密文均应用了相同的密钥我们知道：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>c</mi><mn>1</mn></msub><mo>=</mo><mi>k</mi><mo>⊕</mo><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>c</mi><mn>2</mn></msub><mo>=</mo><mi>k</mi><mo>⊕</mo><msub><mi>m</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>c</mi><mn>1</mn></msub><mo>⊕</mo><msub><mi>c</mi><mn>2</mn></msub><mo>=</mo><msub><mi>m</mi><mn>1</mn></msub><mo>⊕</mo><msub><mi>m</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">c_{1}=k \oplus m_{1},c_{2}=k \oplus m_{2},c_{1}\oplus c_{2}=m_{1}\oplus m_{2} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>根据提示中的考虑空格与 [a-zA-Z] 字符进行亦或运算会改变大小写（a变成A，B变成b）我们可以设置一个判断函数<code>magic()</code>：如果运算结果是0则是相同字符亦或运算，若是合法字符则是一个合法字符和空格运算，其余结果用输出’_'来标记。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">magic</span>(<span class="params">c</span>):</span><br><span class="line">    <span class="keyword">if</span> c == <span class="number">0</span>:  <span class="comment"># same (&#x27;A&#x27; xor &#x27;A&#x27; = &#x27;\x00&#x27;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">chr</span>(c) <span class="keyword">in</span> string.ascii_letters:  <span class="comment"># space xor letter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chr</span>(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;_&#x27;</span></span><br></pre></td></tr></table></figure><p>然后我们来运行以上步骤，通过把11个密文分别两两亦或得到带有提示符的明文亦或结果，然后通过提示字段猜测最长的那个明文具体值（也就是第7个明文（编号为6））</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c1, c2 <span class="keyword">in</span> combinations(MSGS, <span class="number">2</span>):</span><br><span class="line">   xm = strxor(<span class="built_in">bytes</span>.fromhex(c1), <span class="built_in">bytes</span>.fromhex(c2))</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;&#123;:2&#125; &#123;:2&#125;&#x27;</span>.<span class="built_in">format</span>(MSGS.index(c1), MSGS.index(c2)), <span class="string">&#x27;&#x27;</span>.join(magic(i) <span class="keyword">for</span> i <span class="keyword">in</span> xm))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后就是繁琐的猜测明文过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># KEY = strxor(bytes.fromhex(MSGS[10]), b&#x27;The &#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[5]), b&#x27;There are &#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[3]), b&#x27;The ciphertext &#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[10]), b&#x27;The secret message is &#x27;)  # The end is not correct</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[5]), b&#x27;There are two types of &#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[7]), b&#x27;We can see the point where &#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[7]), b&#x27; The Concise OxfordDictionaries &#x27;)  # Interesting; Step back</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[5]), b&#x27;There are two types of crypto&#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[6]), b&#x27;There are two types of cyptography&#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[0]), b&#x27;We can factor the number 15 with quantum&#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[3]), b&#x27;The ciphertext produced by a weak encryption &#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[10]), b&#x27;The secret message is: When using a stream cipher&#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[3]), b&#x27;The ciphertext produced by a weak encryption algorithm &#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[10]), b&#x27;The secret message is: When using a stream cipher, never use &#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[6]), b&#x27;There are two types of cyptography: one that allows the Government &#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[0]), b&#x27;We can factor the number 15 with quantum computers. We can also factor &#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[10]), b&#x27;The secret message is: When using a stream cipher, never use the key more than &#x27;)</span><br><span class="line"># KEY = strxor(bytes.fromhex(MSGS[3]), b&#x27;The ciphertext produced by a weak encryption algorithm looks as good as ciphertext &#x27;)</span><br></pre></td></tr></table></figure><p>最后得到最长的明文是<code>There are two types of cyptography: one that allows the Government to use brute force to break the code, and one that requires the Government to use brute force to break you</code>通过亦或得到密钥最后解出<strong>最终答案</strong>。</p><p><font color = Red><strong>The secret message is: When using a stream cipher, never use the key more than once</strong></font></p><h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">MSGS = (</span><br><span class="line">    <span class="string">&#x27;315c4eeaa8b5f8aaf9174145bf43e1784b8fa00dc71d885a804e5ee9fa40b16349c146fb778cdf2d3aff021dfff5b403b510d0d0455468aeb98622b137dae857553ccd8883a7bc37520e06e515d22c954eba5025b8cc57ee59418ce7dc6bc41556bdb36bbca3e8774301fbcaa3b83b220809560987815f65286764703de0f3d524400a19b159610b11ef3e&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;234c02ecbbfbafa3ed18510abd11fa724fcda2018a1a8342cf064bbde548b12b07df44ba7191d9606ef4081ffde5ad46a5069d9f7f543bedb9c861bf29c7e205132eda9382b0bc2c5c4b45f919cf3a9f1cb74151f6d551f4480c82b2cb24cc5b028aa76eb7b4ab24171ab3cdadb8356f&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;32510ba9a7b2bba9b8005d43a304b5714cc0bb0c8a34884dd91304b8ad40b62b07df44ba6e9d8a2368e51d04e0e7b207b70b9b8261112bacb6c866a232dfe257527dc29398f5f3251a0d47e503c66e935de81230b59b7afb5f41afa8d661cb&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;32510ba9aab2a8a4fd06414fb517b5605cc0aa0dc91a8908c2064ba8ad5ea06a029056f47a8ad3306ef5021eafe1ac01a81197847a5c68a1b78769a37bc8f4575432c198ccb4ef63590256e305cd3a9544ee4160ead45aef520489e7da7d835402bca670bda8eb775200b8dabbba246b130f040d8ec6447e2c767f3d30ed81ea2e4c1404e1315a1010e7229be6636aaa&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;3f561ba9adb4b6ebec54424ba317b564418fac0dd35f8c08d31a1fe9e24fe56808c213f17c81d9607cee021dafe1e001b21ade877a5e68bea88d61b93ac5ee0d562e8e9582f5ef375f0a4ae20ed86e935de81230b59b73fb4302cd95d770c65b40aaa065f2a5e33a5a0bb5dcaba43722130f042f8ec85b7c2070&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd2061bbde24eb76a19d84aba34d8de287be84d07e7e9a30ee714979c7e1123a8bd9822a33ecaf512472e8e8f8db3f9635c1949e640c621854eba0d79eccf52ff111284b4cc61d11902aebc66f2b2e436434eacc0aba938220b084800c2ca4e693522643573b2c4ce35050b0cf774201f0fe52ac9f26d71b6cf61a711cc229f77ace7aa88a2f19983122b11be87a59c355d25f8e4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;32510bfbacfbb9befd54415da243e1695ecabd58c519cd4bd90f1fa6ea5ba47b01c909ba7696cf606ef40c04afe1ac0aa8148dd066592ded9f8774b529c7ea125d298e8883f5e9305f4b44f915cb2bd05af51373fd9b4af511039fa2d96f83414aaaf261bda2e97b170fb5cce2a53e675c154c0d9681596934777e2275b381ce2e40582afe67650b13e72287ff2270abcf73bb028932836fbdecfecee0a3b894473c1bbeb6b4913a536ce4f9b13f1efff71ea313c8661dd9a4ce&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;315c4eeaa8b5f8bffd11155ea506b56041c6a00c8a08854dd21a4bbde54ce56801d943ba708b8a3574f40c00fff9e00fa1439fd0654327a3bfc860b92f89ee04132ecb9298f5fd2d5e4b45e40ecc3b9d59e9417df7c95bba410e9aa2ca24c5474da2f276baa3ac325918b2daada43d6712150441c2e04f6565517f317da9d3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;271946f9bbb2aeadec111841a81abc300ecaa01bd8069d5cc91005e9fe4aad6e04d513e96d99de2569bc5e50eeeca709b50a8a987f4264edb6896fb537d0a716132ddc938fb0f836480e06ed0fcd6e9759f40462f9cf57f4564186a2c1778f1543efa270bda5e933421cbe88a4a52222190f471e9bd15f652b653b7071aec59a2705081ffe72651d08f822c9ed6d76e48b63ab15d0208573a7eef027&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;466d06ece998b7a2fb1d464fed2ced7641ddaa3cc31c9941cf110abbf409ed39598005b3399ccfafb61d0315fca0a314be138a9f32503bedac8067f03adbf3575c3b8edc9ba7f537530541ab0f9f3cd04ff50d66f1d559ba520e89a2cb2a83&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;32510ba9babebbbefd001547a810e67149caee11d945cd7fc81a05e9f85aac650e9052ba6a8cd8257bf14d13e6f0a803b54fde9e77472dbff89d71b57bddef121336cb85ccb8f3315f4b52e301d16e9f52f904&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">strxor</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a) &gt; <span class="built_in">len</span>(b):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>([x ^ y <span class="keyword">for</span> (x, y) <span class="keyword">in</span> <span class="built_in">zip</span>(a[:<span class="built_in">len</span>(b)], b)])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>([x ^ y <span class="keyword">for</span> (x, y) <span class="keyword">in</span> <span class="built_in">zip</span>(a, b[:<span class="built_in">len</span>(a)])])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">magic</span>(<span class="params">c</span>):</span><br><span class="line">    <span class="keyword">if</span> c == <span class="number">0</span>:  <span class="comment"># same (&#x27;A&#x27; xor &#x27;A&#x27; = &#x27;\x00&#x27;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">chr</span>(c) <span class="keyword">in</span> string.ascii_letters:  <span class="comment"># space xor letter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">chr</span>(c)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;_&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c1, c2 <span class="keyword">in</span> combinations(MSGS, <span class="number">2</span>):</span><br><span class="line">        xm = strxor(<span class="built_in">bytes</span>.fromhex(c1), <span class="built_in">bytes</span>.fromhex(c2))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;:2&#125; &#123;:2&#125;&#x27;</span>.<span class="built_in">format</span>(MSGS.index(c1), MSGS.index(c2)), <span class="string">&#x27;&#x27;</span>.join(magic(i) <span class="keyword">for</span> i <span class="keyword">in</span> xm))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n开始猜明文～（很显然先猜大部分都是_的字母，然后疯狂填字）\n&#x27;</span>)</span><br><span class="line">    KEY = strxor(<span class="built_in">bytes</span>.fromhex(MSGS[<span class="number">6</span>]), <span class="string">b&#x27;There are two types of cyptography: one that allows the Government to use brute force to break the code, and one that requires the Government to use brute force to break you&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> x, m <span class="keyword">in</span> <span class="built_in">enumerate</span>(MSGS):</span><br><span class="line">        <span class="built_in">print</span>(x, strxor(<span class="built_in">bytes</span>.fromhex(m), KEY).decode(encoding= <span class="string">&#x27;utf-8&#x27;</span>,errors=<span class="string">&#x27;ignore&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(KEY.<span class="built_in">hex</span>())</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="2-PA1-option">2. PA1 option</h2><p>Write a program that allows you to “crack” ciphertexts generated using a Vigenere-like cipher, where byte-wise XOR is used instead of addition modulo 26.</p><h3 id="题目分析-2">题目分析</h3><p>简单来说就是解密vigenere的密码，但是其中运算过程是使用逐字节异或而不是加法模26。<br>所以我们首先需要得到密钥<code>key</code>，所以我们要定义一个寻找可能密钥字符的函数<code>find_index_key(sub_arr)</code>。这里定义all_key为所有可能的字符，包括字母、数字、逗号、点和空格。初始化两个列表test_key和possible_key。遍历test_key中的每个值（ASCII字符），并对sub_arr中的每个字节进行亦或，如果结果不在all_key中，则将该ASCII值从possible_key中移除。最后返回possible_key。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_index_key</span>(<span class="params">sub_arr</span>): </span><br><span class="line">    all_key = ascii_letters + digits + <span class="string">&#x27;,&#x27;</span> + <span class="string">&#x27;.&#x27;</span> + <span class="string">&#x27; &#x27;</span></span><br><span class="line">    test_key = []</span><br><span class="line">    possible_key = []</span><br><span class="line">    <span class="comment"># 遍历整个ascii码(0-127)</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x00</span>, <span class="number">0xFF</span>):</span><br><span class="line">        test_key.append(x)</span><br><span class="line">        possible_key.append(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> test_key:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> sub_arr:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">chr</span>(i ^ j) <span class="keyword">not</span> <span class="keyword">in</span> all_key:</span><br><span class="line">                possible_key.remove(i)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> possible_key</span><br></pre></td></tr></table></figure><p>然后遍历<code>key</code>的长度，然后和密文进行亦或运算查看可能的密钥可能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key_len <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">30</span>):</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(key_len):</span><br><span class="line">        sub_arr = ct[index::key_len]  </span><br><span class="line">        possible_ch = find_index_key(sub_arr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;key_len = &#x27;</span>, key_len, <span class="string">&#x27;index = &#x27;</span>, index, <span class="string">&#x27;possible_ch = &#x27;</span>, possible_ch)</span><br><span class="line">        <span class="keyword">if</span> possible_ch:</span><br><span class="line">            k = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> possible_ch:</span><br><span class="line">                k.append(<span class="built_in">chr</span>(j ^ sub_arr[<span class="number">0</span>]))</span><br><span class="line">            <span class="built_in">print</span>(k)</span><br></pre></td></tr></table></figure><p>输出的部分结果如下（这里的index便于定位密钥的位置）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">key_len =  7 index =  0 possible_ch =  [186]</span><br><span class="line">[&#x27;C&#x27;]</span><br><span class="line">key_len =  7 index =  1 possible_ch =  [31]</span><br><span class="line">[&#x27;r&#x27;]</span><br><span class="line">key_len =  7 index =  2 possible_ch =  [145]</span><br><span class="line">[&#x27;y&#x27;]</span><br><span class="line">key_len =  7 index =  3 possible_ch =  [178]</span><br><span class="line">[&#x27;p&#x27;]</span><br><span class="line">key_len =  7 index =  4 possible_ch =  [83]</span><br><span class="line">[&#x27;t&#x27;]</span><br><span class="line">key_len =  7 index =  5 possible_ch =  [205]</span><br><span class="line">[&#x27;o&#x27;]</span><br><span class="line">key_len =  7 index =  6 possible_ch =  [62]</span><br><span class="line">[&#x27;g&#x27;]</span><br></pre></td></tr></table></figure><p>得到关键的密钥<code>key = [186, 31, 145, 178, 83, 205, 62]</code><br>最后带入就能解出明文，<strong>最终答案</strong></p><p><font color = Red><strong>Cryptography is the practice and study of techniques for, among other things, secure communication in the presence of attackers. Cryptography has been used for hundreds, if not thousands, of years, but traditional cryptosystems were designed and evaluated in a fairly ad hoc manner. For example, the Vigenere encryption scheme was thought to be secure for decades after it was invented, but we now know, and this exercise demonstrates, that it can be broken very easily.</strong></font></p><h3 id="完整代码-2">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> ascii_letters, digits</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_index_key</span>(<span class="params">sub_arr</span>): </span><br><span class="line">    all_key = ascii_letters + digits + <span class="string">&#x27;,&#x27;</span> + <span class="string">&#x27;.&#x27;</span> + <span class="string">&#x27; &#x27;</span></span><br><span class="line">    test_key = []</span><br><span class="line">    possible_key = []</span><br><span class="line">    <span class="comment"># 遍历整个ascii码(0-127)</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x00</span>, <span class="number">0xFF</span>):</span><br><span class="line">        test_key.append(x)</span><br><span class="line">        possible_key.append(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> test_key:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> sub_arr:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">chr</span>(i ^ j) <span class="keyword">not</span> <span class="keyword">in</span> all_key:</span><br><span class="line">                possible_key.remove(i)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> possible_key</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;F96DE8C227A259C87EE1DA2AED57C93FE5DA36ED4EC87EF2C63AAE5B9A7EFFD673BE4ACF7BE8923CAB1ECE7AF2DA3DA44FCF7AE29235A24C963FF0DF3CA3599A70E5DA36BF1ECE77F8DC34BE129A6CF4D126BF5B9A7CFEDF3EB850D37CF0C63AA2509A76FF9227A55B9A6FE3D720A850D97AB1DD35ED5FCE6BF0D138A84CC931B1F121B44ECE70F6C032BD56C33FF9D320ED5CDF7AFF9226BE5BDE3FF7DD21ED56CF71F5C036A94D963FF8D473A351CE3FE5DA3CB84DDB71F5C17FED51DC3FE8D732BF4D963FF3C727ED4AC87EF5DB27A451D47EFD9230BF47CA6BFEC12ABE4ADF72E29224A84CDF3FF5D720A459D47AF59232A35A9A7AE7D33FB85FCE7AF5923AA31EDB3FF7D33ABF52C33FF0D673A551D93FFCD33DA35BC831B1F43CBF1EDF67F0DF23A15B963FE5DA36ED68D378F4DC36BF5B9A7AFFD121B44ECE76FEDC73BE5DD27AFCD773BA5FC93FE5DA3CB859D26BB1C63CED5CDF3FE2D730B84CDF3FF7DD21ED5ADF7CF0D636BE1EDB79E5D721ED57CE3FE6D320ED57D469F4DC27A85A963FF3C727ED49DF3FFFDD24ED55D470E69E73AC50DE3FE5DA3ABE1EDF67F4C030A44DDF3FF5D73EA250C96BE3D327A84D963FE5DA32B91ED36BB1D132A31ED87AB1D021A255DF71B1C436BF479A7AF0C13AA14794&quot;</span></span><br><span class="line">ct = <span class="built_in">bytes</span>.fromhex(s)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key_len <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">30</span>):</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(key_len):</span><br><span class="line">        sub_arr = ct[index::key_len]  </span><br><span class="line">        possible_ch = find_index_key(sub_arr)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;key_len = &#x27;</span>, key_len, <span class="string">&#x27;index = &#x27;</span>, index, <span class="string">&#x27;possible_ch = &#x27;</span>, possible_ch)</span><br><span class="line">        <span class="keyword">if</span> possible_ch:</span><br><span class="line">            k = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> possible_ch:</span><br><span class="line">                k.append(<span class="built_in">chr</span>(j ^ sub_arr[<span class="number">0</span>]))</span><br><span class="line">            <span class="built_in">print</span>(k)</span><br><span class="line"></span><br><span class="line">key = [<span class="number">186</span>, <span class="number">31</span>, <span class="number">145</span>, <span class="number">178</span>, <span class="number">83</span>, <span class="number">205</span>, <span class="number">62</span>]</span><br><span class="line">pt = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ct)):</span><br><span class="line">    pt += <span class="built_in">chr</span>(ct[i] ^ key[i % <span class="number">7</span>])</span><br><span class="line"><span class="built_in">print</span>(pt)</span><br></pre></td></tr></table></figure><h2 id="3-Crypto-Challenge-Set-1-link">3.Crypto Challenge Set 1(<a href="http://www.cryptopals.com/sets/1">link</a>)</h2><h3 id="1-Convert-hex-to-base64">(1)Convert hex to base64</h3><p>如题就是把十六进制转化为base64</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hex_to_base64</span>(<span class="params">hex_data</span>):</span><br><span class="line">    base64_string = base64.b64encode(<span class="built_in">bytes</span>.fromhex(hex_data)).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> base64_string</span><br></pre></td></tr></table></figure><h3 id="2-Fixed-XOR">(2)Fixed XOR</h3><p>等长亦或运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fixed_xor</span>(<span class="params">hex_str1, hex_str2</span>):</span><br><span class="line">    byte_str1 = <span class="built_in">bytes</span>.fromhex(hex_str1)</span><br><span class="line">    byte_str2 = <span class="built_in">bytes</span>.fromhex(hex_str2)</span><br><span class="line">    xor_result = <span class="built_in">bytes</span>([b1 ^ b2 <span class="keyword">for</span> b1, b2 <span class="keyword">in</span> <span class="built_in">zip</span>(byte_str1, byte_str2)])</span><br><span class="line">    hex_result = xor_result.<span class="built_in">hex</span>()</span><br><span class="line">    <span class="keyword">return</span> hex_result</span><br></pre></td></tr></table></figure><h3 id="3-Single-byte-XOR-cipher">(3)Single-byte XOR cipher</h3><p>因为是单个字节的亦或密码，并且选取字母分数最高的密钥，所以遍历所有的<code>key</code>。选取明文中英文字符占比分数最大的明文和密钥。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_single_byte_xor</span>(<span class="params">cipher_hex</span>):</span><br><span class="line">    cipher_bytes = codecs.decode(cipher_hex, <span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_english</span>(<span class="params">text</span>):</span><br><span class="line">        <span class="keyword">return</span> text.isascii() <span class="keyword">and</span> text.isprintable()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">english_score</span>(<span class="params">text</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> char <span class="keyword">in</span> text <span class="keyword">if</span> char.isalpha())</span><br><span class="line">    best_key = <span class="literal">None</span></span><br><span class="line">    best_score = -<span class="number">1</span></span><br><span class="line">    best_plaintext = <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        decrypted = <span class="built_in">bytes</span>([cipher_bytes[i] ^ key <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher_bytes))])</span><br><span class="line">        decrypted_text = decrypted.decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> is_english(decrypted_text):</span><br><span class="line">            score = english_score(decrypted_text)</span><br><span class="line">            <span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">                best_score = score</span><br><span class="line">                best_key = key</span><br><span class="line">                best_plaintext = decrypted_text</span><br><span class="line">    <span class="keyword">return</span> best_plaintext, best_key</span><br><span class="line"></span><br><span class="line">cipher_hex = <span class="string">&quot;1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736&quot;</span></span><br><span class="line">decrypted_text, key = decrypt_single_byte_xor(cipher_hex)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decrypted Text:&quot;</span>, decrypted_text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Key:&quot;</span>, <span class="built_in">hex</span>(key))</span><br></pre></td></tr></table></figure><p>运行代码解出答案</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Decrypted Text: Cooking MC&#x27;s like a pound of bacon</span><br><span class="line">Key: 0x58</span><br></pre></td></tr></table></figure><h3 id="4-Detect-single-character-XOR">(4)Detect single-character XOR</h3><p>这个引入上一问的函数并且加入字符频次表。通过逐行读取密文并且应用单字符密钥得到每行最高分数的key。最后选取出最高分数的明文作为答案输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_english_score</span>(<span class="params">input_bytes</span>):</span><br><span class="line">    character_frequencies = &#123;</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>: <span class="number">.08167</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">.01492</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">.02782</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">.04253</span>,</span><br><span class="line">        <span class="string">&#x27;e&#x27;</span>: <span class="number">.12702</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">.02228</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">.02015</span>, <span class="string">&#x27;h&#x27;</span>: <span class="number">.06094</span>,</span><br><span class="line">        <span class="string">&#x27;i&#x27;</span>: <span class="number">.06094</span>, <span class="string">&#x27;j&#x27;</span>: <span class="number">.00153</span>, <span class="string">&#x27;k&#x27;</span>: <span class="number">.00772</span>, <span class="string">&#x27;l&#x27;</span>: <span class="number">.04025</span>,</span><br><span class="line">        <span class="string">&#x27;m&#x27;</span>: <span class="number">.02406</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">.06749</span>, <span class="string">&#x27;o&#x27;</span>: <span class="number">.07507</span>, <span class="string">&#x27;p&#x27;</span>: <span class="number">.01929</span>,</span><br><span class="line">        <span class="string">&#x27;q&#x27;</span>: <span class="number">.00095</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">.05987</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">.06327</span>, <span class="string">&#x27;t&#x27;</span>: <span class="number">.09056</span>,</span><br><span class="line">        <span class="string">&#x27;u&#x27;</span>: <span class="number">.02758</span>, <span class="string">&#x27;v&#x27;</span>: <span class="number">.00978</span>, <span class="string">&#x27;w&#x27;</span>: <span class="number">.02360</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">.00150</span>,</span><br><span class="line">        <span class="string">&#x27;y&#x27;</span>: <span class="number">.01974</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">.00074</span>, <span class="string">&#x27; &#x27;</span>: <span class="number">.13000</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>([character_frequencies.get(<span class="built_in">chr</span>(byte), <span class="number">0</span>) <span class="keyword">for</span> byte <span class="keyword">in</span> input_bytes.lower()])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">single_char_xor</span>(<span class="params">input_bytes, char_value</span>):</span><br><span class="line">    output_bytes = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> input_bytes:</span><br><span class="line">        output_bytes += <span class="built_in">bytes</span>([byte ^ char_value])</span><br><span class="line">    <span class="keyword">return</span> output_bytes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bruteforce_single_char_xor</span>(<span class="params">ciphertext</span>):</span><br><span class="line">    potential_messages = []</span><br><span class="line">    <span class="keyword">for</span> key_value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        message = single_char_xor(ciphertext, key_value)</span><br><span class="line">        score = get_english_score(message)</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&#x27;message&#x27;</span>: message,</span><br><span class="line">            <span class="string">&#x27;score&#x27;</span>: score,</span><br><span class="line">            <span class="string">&#x27;key&#x27;</span>: key_value</span><br><span class="line">        &#125;</span><br><span class="line">        potential_messages.append(data)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(potential_messages, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;score&#x27;</span>], reverse=<span class="literal">True</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_xor_cipher</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        lines = file.readlines()</span><br><span class="line">        best_plaintext = <span class="string">&quot;&quot;</span></span><br><span class="line">        best_key = <span class="literal">None</span></span><br><span class="line">        best_score = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            cipher_hex = line.strip()</span><br><span class="line">            ciphertext = <span class="built_in">bytes</span>.fromhex(cipher_hex)</span><br><span class="line">            result = bruteforce_single_char_xor(ciphertext)</span><br><span class="line">            <span class="keyword">if</span> result[<span class="string">&#x27;score&#x27;</span>] &gt; best_score:</span><br><span class="line">                best_score = result[<span class="string">&#x27;score&#x27;</span>]</span><br><span class="line">                best_plaintext = result[<span class="string">&#x27;message&#x27;</span>]</span><br><span class="line">                best_key = result[<span class="string">&#x27;key&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> best_plaintext, <span class="built_in">hex</span>(best_key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    file_path = <span class="string">&quot;plain.txt&quot;</span></span><br><span class="line">    detected_plaintext, key = detect_xor_cipher(file_path)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;plaintext: &quot;</span>,detected_plaintext.decode())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Key: <span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><strong>最终答案</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plaintext:  Now that the party is jumping</span><br><span class="line"></span><br><span class="line">Key: 0x35</span><br></pre></td></tr></table></figure><h3 id="5-Implement-repeating-key-XOR">(5)Implement repeating-key XOR</h3><p>这个就是重复密钥进行亦或操作，代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">plaintext, key</span>):</span><br><span class="line">    repeated_key = (key * (<span class="built_in">len</span>(plaintext) // <span class="built_in">len</span>(key))) + key[:<span class="built_in">len</span>(plaintext) % <span class="built_in">len</span>(key)]</span><br><span class="line">    encrypted_decrypted = <span class="built_in">bytes</span>([p ^ k <span class="keyword">for</span> p, k <span class="keyword">in</span> <span class="built_in">zip</span>(plaintext.encode(), repeated_key.encode())])</span><br><span class="line">    <span class="keyword">return</span> encrypted_decrypted.<span class="built_in">hex</span>()</span><br><span class="line"></span><br><span class="line">plaintext = <span class="string">&#x27;&#x27;&#x27;Burning &#x27;em, if you ain&#x27;t quick and nimble I go crazy when I hear a cymbal&#x27;&#x27;&#x27;</span></span><br><span class="line">key = <span class="string">&quot;ICE&quot;</span></span><br><span class="line">encrypted1 = xor(plaintext, key)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Encrypted:&quot;</span>, encrypted1)</span><br></pre></td></tr></table></figure><h3 id="6-Break-repeating-key-XOR">(6)Break repeating-key XOR</h3><p>首先要猜测密钥的长度这里范围由题目所述（2到40），设置了计算汉明距离的函数<code>hamming_distance(a, b)</code>其后继承上述题目的代码得到最高字符频次分数的密码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">English_Scoring</span>(<span class="params">t</span>):</span><br><span class="line">    letter_frequency = &#123;</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>: <span class="number">.08167</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">.01492</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">.02782</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">.04253</span>,</span><br><span class="line">        <span class="string">&#x27;e&#x27;</span>: <span class="number">.12702</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">.02228</span>, <span class="string">&#x27;g&#x27;</span>: <span class="number">.02015</span>, <span class="string">&#x27;h&#x27;</span>: <span class="number">.06094</span>,</span><br><span class="line">        <span class="string">&#x27;i&#x27;</span>: <span class="number">.06094</span>, <span class="string">&#x27;j&#x27;</span>: <span class="number">.00153</span>, <span class="string">&#x27;k&#x27;</span>: <span class="number">.00772</span>, <span class="string">&#x27;l&#x27;</span>: <span class="number">.04025</span>,</span><br><span class="line">        <span class="string">&#x27;m&#x27;</span>: <span class="number">.02406</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">.06749</span>, <span class="string">&#x27;o&#x27;</span>: <span class="number">.07507</span>, <span class="string">&#x27;p&#x27;</span>: <span class="number">.01929</span>,</span><br><span class="line">        <span class="string">&#x27;q&#x27;</span>: <span class="number">.00095</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">.05987</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">.06327</span>, <span class="string">&#x27;t&#x27;</span>: <span class="number">.09056</span>,</span><br><span class="line">        <span class="string">&#x27;u&#x27;</span>: <span class="number">.02758</span>, <span class="string">&#x27;v&#x27;</span>: <span class="number">.00978</span>, <span class="string">&#x27;w&#x27;</span>: <span class="number">.02360</span>, <span class="string">&#x27;x&#x27;</span>: <span class="number">.00150</span>,</span><br><span class="line">        <span class="string">&#x27;y&#x27;</span>: <span class="number">.01974</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">.00074</span>, <span class="string">&#x27; &#x27;</span>: <span class="number">.15000</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>([letter_frequency.get(<span class="built_in">chr</span>(i), <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> t.lower()])  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Single_XOR</span>(<span class="params">s, single_character</span>):</span><br><span class="line">    t = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        t += <span class="built_in">bytes</span>([i ^ single_character])</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ciphertext_XOR</span>(<span class="params">s</span>):</span><br><span class="line">    _data = []</span><br><span class="line">    <span class="keyword">for</span> single_character <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        ciphertext = Single_XOR(s, single_character)</span><br><span class="line">        score = English_Scoring(ciphertext)</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&#x27;Single character&#x27;</span>: single_character,</span><br><span class="line">            <span class="string">&#x27;ciphertext&#x27;</span>: ciphertext,</span><br><span class="line">            <span class="string">&#x27;score&#x27;</span>: score</span><br><span class="line">        &#125;</span><br><span class="line">        _data.append(data)</span><br><span class="line">    score = <span class="built_in">sorted</span>(_data, key=<span class="keyword">lambda</span> score: score[<span class="string">&#x27;score&#x27;</span>], reverse=<span class="literal">True</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Repeating_key_XOR</span>(<span class="params">_cipher, _key</span>):</span><br><span class="line">    message = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    length = <span class="built_in">len</span>(_key)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(_cipher)):</span><br><span class="line">        message += <span class="built_in">bytes</span>([_cipher[i] ^ _key[i % length]])</span><br><span class="line">    <span class="keyword">return</span> message</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hamming_distance</span>(<span class="params">a, b</span>):</span><br><span class="line">    distance = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(a, b):</span><br><span class="line">        byte = i ^ j</span><br><span class="line">        distance += <span class="built_in">sum</span>(k == <span class="string">&#x27;1&#x27;</span> <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">bin</span>(byte))</span><br><span class="line">    <span class="keyword">return</span> distance</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Get_the_keysize</span>(<span class="params">ciphertext</span>):</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> keysize <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">41</span>):</span><br><span class="line">        block = [ciphertext[i:i + keysize] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(ciphertext), keysize)]</span><br><span class="line">        distances = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(block) - <span class="number">1</span>):</span><br><span class="line">            block1 = block[i]</span><br><span class="line">            block2 = block[i + <span class="number">1</span>]</span><br><span class="line">            distance = hamming_distance(block1, block2)</span><br><span class="line">            distances.append(distance / keysize)</span><br><span class="line">        _distance = <span class="built_in">sum</span>(distances) / <span class="built_in">len</span>(distances)</span><br><span class="line">        _data = &#123;</span><br><span class="line">            <span class="string">&#x27;keysize&#x27;</span>: keysize,</span><br><span class="line">            <span class="string">&#x27;distance&#x27;</span>: _distance</span><br><span class="line">        &#125;</span><br><span class="line">        data.append(_data)</span><br><span class="line">    _keysize = <span class="built_in">sorted</span>(data, key=<span class="keyword">lambda</span> distance: distance[<span class="string">&#x27;distance&#x27;</span>])[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> _keysize</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Break_repeating_key_XOR</span>(<span class="params">ciphertext</span>):</span><br><span class="line">    _keysize = Get_the_keysize(ciphertext)</span><br><span class="line">    keysize = _keysize[<span class="string">&#x27;keysize&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;keysize:&quot;</span>, keysize)</span><br><span class="line">    key = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    message = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    block = [ciphertext[i:i + keysize] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(ciphertext), keysize)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(keysize):</span><br><span class="line">        new_block = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(block) - <span class="number">1</span>):</span><br><span class="line">            s = block[j]</span><br><span class="line">            new_block += <span class="built_in">bytes</span>([s[i]])</span><br><span class="line">        score = ciphertext_XOR(new_block)</span><br><span class="line">        key += <span class="built_in">bytes</span>([score[<span class="string">&#x27;Single character&#x27;</span>]])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(block)):</span><br><span class="line">        message += Repeating_key_XOR(block[k], key)</span><br><span class="line">    <span class="keyword">return</span> message, key</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;decription.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> of:</span><br><span class="line">        ciphertext = of.read()</span><br><span class="line">        ciphertext = base64.b64decode(ciphertext)</span><br><span class="line">    message, key = Break_repeating_key_XOR(ciphertext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;message:&quot;</span>, message.decode(<span class="string">&#x27;utf-8&#x27;</span>), <span class="string">&quot;\nkey:&quot;</span>, key.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>最后运算出密钥长度为<code>29</code>，<code>key: Terminator X: Bring the noise</code>解密后的明文为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m back and I&#x27;m ringin&#x27; the bell </span><br><span class="line">A rockin&#x27; on the mike while the fly girls yell </span><br><span class="line">In ecstasy in the back of me </span><br><span class="line">Well that&#x27;s my DJ Deshay cuttin&#x27; all them Z&#x27;s </span><br><span class="line">Hittin&#x27; hard and the girlies goin&#x27; crazy </span><br><span class="line">Vanilla&#x27;s on the mike, man I&#x27;m not lazy. </span><br><span class="line"></span><br><span class="line">I&#x27;m lettin&#x27; my drug kick in </span><br><span class="line">It controls my mouth and I begin </span><br><span class="line">To just let it flow, let my concepts go </span><br><span class="line">My posse&#x27;s to the side yellin&#x27;, Go Vanilla Go! </span><br><span class="line"></span><br><span class="line">Smooth &#x27;cause that&#x27;s the way I will be </span><br><span class="line">And if you don&#x27;t give a damn, then </span><br><span class="line">Why you starin&#x27; at me </span><br><span class="line">So get off &#x27;cause I control the stage </span><br><span class="line">There&#x27;s no dissin&#x27; allowed </span><br><span class="line">I&#x27;m in my own phase </span><br><span class="line">The girlies sa y they love me and that is ok </span><br><span class="line">And I can dance better than any kid n&#x27; play </span><br><span class="line"></span><br><span class="line">Stage 2 -- Yea the one ya&#x27; wanna listen to </span><br><span class="line">It&#x27;s off my head so let the beat play through </span><br><span class="line">So I can funk it up and make it sound good </span><br><span class="line">1-2-3 Yo -- Knock on some wood </span><br><span class="line">For good luck, I like my rhymes atrocious </span><br><span class="line">Supercalafragilisticexpialidocious </span><br><span class="line">I&#x27;m an effect and that you can bet </span><br><span class="line">I can take a fly girl and make her wet. </span><br><span class="line"></span><br><span class="line">I&#x27;m like Samson -- Samson to Delilah </span><br><span class="line">There&#x27;s no denyin&#x27;, You can try to hang </span><br><span class="line">But you&#x27;ll keep tryin&#x27; to get my style </span><br><span class="line">Over and over, practice makes perfect </span><br><span class="line">But not if you&#x27;re a loafer. </span><br><span class="line"></span><br><span class="line">You&#x27;ll get nowhere, no place, no time, no girls </span><br><span class="line">Soon -- Oh my God, homebody, you probably eat </span><br><span class="line">Spaghetti with a spoon! Come on and say it! </span><br><span class="line"></span><br><span class="line">VIP. Vanilla Ice yep, yep, I&#x27;m comin&#x27; hard like a rhino </span><br><span class="line">Intoxicating so you stagger like a wino </span><br><span class="line">So punks stop trying and girl stop cryin&#x27; </span><br><span class="line">Vanilla Ice is sellin&#x27; and you people are buyin&#x27; </span><br><span class="line">&#x27;Cause why the freaks are jockin&#x27; like Crazy Glue </span><br><span class="line">Movin&#x27; and groovin&#x27; trying to sing along </span><br><span class="line">All through the ghetto groovin&#x27; this here song </span><br><span class="line">Now you&#x27;re amazed by the VIP posse. </span><br><span class="line"></span><br><span class="line">Steppin&#x27; so hard like a German Nazi </span><br><span class="line">Startled by the bases hittin&#x27; ground </span><br><span class="line">There&#x27;s no trippin&#x27; on mine, I&#x27;m just gettin&#x27; down </span><br><span class="line">Sparkamatic, I&#x27;m hangin&#x27; tight like a fanatic </span><br><span class="line">You trapped me once and I thought that </span><br><span class="line">You might have it </span><br><span class="line">So step down and lend me your ear </span><br><span class="line">&#x27;89 in my time! You, &#x27;90 is my year. </span><br><span class="line"></span><br><span class="line">You&#x27;re weakenin&#x27; fast, YO! and I can tell it </span><br><span class="line">Your body&#x27;s gettin&#x27; hot, so, so I can smell it </span><br><span class="line">So don&#x27;t be mad and don&#x27;t be sad </span><br><span class="line">&#x27;Cause the lyrics belong to ICE, You can call me Dad </span><br><span class="line">You&#x27;re pitchin&#x27; a fit, so step back and endure </span><br><span class="line">Let the witch doctor, Ice, do the dance to cure </span><br><span class="line">So come up close and don&#x27;t be square </span><br><span class="line">You wanna battle me -- Anytime, anywhere </span><br><span class="line"></span><br><span class="line">You thought that I was weak, Boy, you&#x27;re dead wrong </span><br><span class="line">So come on, everybody and sing this song </span><br><span class="line"></span><br><span class="line">Say -- Play that funky music Say, go white boy, go white boy go </span><br><span class="line">play that funky music Go white boy, go white boy, go </span><br><span class="line">Lay down and boogie and play that funky music till you die. </span><br><span class="line"></span><br><span class="line">Play that funky music Come on, Come on, let me hear </span><br><span class="line">Play that funky music white boy you say it, say it </span><br><span class="line">Play that funky music A little louder now </span><br><span class="line">Play that funky music, white boy Come on, Come on, Come on </span><br><span class="line">Play that funky music</span><br></pre></td></tr></table></figure><h2 id="4-MTC3-Cracking-SHA1-Hashed-Passwords">4.MTC3 Cracking SHA1-Hashed Passwords</h2><p>题目链接(<a href="https://www.mysterytwisterc3.org/en/challenges/level-2/cracking-sha1-hashed-passwords">link</a>)</p><p>根据图片中键盘上的指纹分布，可以看出右边的数字键只有2486，很有可能是当做上下左右的功能，（常识这个应该是没有在密钥里的）所以就可以将密钥空间缩小。然后逐一写出剩余的可能按键，最后写一个dfs算法遍历每一种情况再用SHA1加密最后和给定哈希值比对。这里设置时钟得到运行时间为<code>1s</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">hash1 = <span class="string">&quot;67ae1a64661ac8b4494666f58c4822408dd0a3e4&quot;</span></span><br><span class="line">str2 = [[<span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;q&#x27;</span>], [<span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;w&#x27;</span>], [<span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;5&#x27;</span>], [<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;(&#x27;</span>], [<span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;0&#x27;</span>], [<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;i&#x27;</span>], [<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;+&#x27;</span>], [<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;N&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sha_encrypt</span>(<span class="params">string</span>):</span><br><span class="line">    sha = hashlib.sha1(string.encode())</span><br><span class="line">    <span class="keyword">return</span> sha.hexdigest()</span><br><span class="line"></span><br><span class="line">starttime = datetime.datetime.now()</span><br><span class="line"><span class="keyword">for</span> combination <span class="keyword">in</span> itertools.product(*str2):</span><br><span class="line">    <span class="keyword">for</span> perm <span class="keyword">in</span> itertools.permutations(combination):</span><br><span class="line">        candidate = <span class="string">&quot;&quot;</span>.join(perm)</span><br><span class="line">        <span class="keyword">if</span> sha_encrypt(candidate) == hash1:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ans:&quot;</span>, candidate)</span><br><span class="line">            endtime = datetime.datetime.now()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;t:&quot;</span>, (endtime - starttime).seconds, <span class="string">&quot;seconds&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Password not found.&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="实验总结">实验总结</h2><p>本次试验我学会了编写简单的密码算法，对编码和加解密的过程更加熟悉。其中在第一个实验中我一开始是通过对亦或后明文的特征进行条件限制来爆破明文信息，但是总会有几位出现乱码，所以说我基于之前部分爆破的明文选择通过人为分析这些亦或后的明文特征，推测出最长的一条明文信息，最后得到密钥解密。</p><h2 id="源代码链接">源代码链接</h2><p><a href="https://github.com/cool-chicken/cryptography-exp/tree/main/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C%E4%B8%80">https://github.com/cool-chicken/cryptography-exp/tree/main/密码学实验一</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学实验 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
  
</search>
